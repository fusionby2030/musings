---
title: "Some Automating"

execute: 
  echo: false
  warning: false

---


```{python}
import os 
import numpy as np
from io import BytesIO
from helper_functions import get_allas_connection, get_dict_params
import matplotlib.pyplot as plt 
import matplotlib.gridspec as gridspec
conn = get_allas_connection()
raw_dir = '/home/adam/ENR_Sven/moxie/data/raw/RAW_JET_PULSES'
# raw_dir = '/home/kitadam/ENR_Sven/moxie/data/raw/RAW_JET_PULSES'

# rel_dir = '/home/kitadam/ENR_Sven/supervised_learning_jetpdb/data/jet-all-full.csv'
# jet_pdb_all = pd.read_csv(rel_dir)
shot_list = [fname for fname in os.listdir(raw_dir)]
import random 
random.seed(44)
sample_shot_nums = random.sample(shot_list, k=5)

if os.getenv('PLOTSTYLE') is not None: 
    plt.style.use(os.getenv('PLOTSTYLE'))
```

Datasets in fusion are commonly but finding relevant time windows of desired signals.  

This process is commonly done by experts in the field, who know what they are looking for, but is a very manual instensive process. 
Take for example, the JET Pedestal Database @Frassinetti2021. 

- The time windows are within H-mode an manually selected
- The ELM timings are likely hand-checked then correlated with the profile measurements
- Fitting of profiles with MTANH

So we want to do this process, automatically and possibly compare models trained on JET PDB vs automated JET PDB. 

# What do we want to automate

Three things: 

1. Finding Steady-states inside H-Mode 
    - H-mode is a bit easier 
    - Steady states will be tricky 
2. ELM timings 
    - Also Tricky 
3. Curve fitting
    - Bayesian :--)


## 1. Finding H-mode

The amount of power needed to enter H-mode is commonly described as the L-H threshold, or $P_{LH}$. 

An example of a scaling law derived in terms of machine parameters is given in @Martin_2008: 

$$P_{\text{LH}} [\text{MW}] = 2.15e^{\pm 0.107} n_{e20}^{0.728 \pm 0.037} B_T^{0.772 \pm 0.031} a^{0.975\pm 0.08} R^{0.999\pm 0.101 }$$
where $B_T$ [T], $n_e$ [$10^{20}$ m $^{-2}$], $a$ [m], $R$ [m] are the magnitude of the toroidal magnetic field, line averaged electron density, major and minor plasma radius, respectively. The shaping parameters are sometimes refered to as $S$, or parameterized as the surface area. 
This can be intuitively thought of as given some volume of plasma, with surface area $S$ and density $n$, that is confined by a magnetic field $B$, there exists some amount of power needed to excited it to pass into a new regime. 

Thus, we are looking for the times where the total power injected is greator than $P_\text{LH}$:  $P_\text{TOT} \geq P_{\text{LH}}$, or $\frac{P_\text{TOT}}{P_{\text{LH}}} \geq 1.0$. 

For JET, the total power is typically coming from NBI, ICR, and Ohmic heating sources, $P_\text{NBI}, P_\text{ICR}, P_\text{OH}$ and there is some shine through lost deposited on the wall $P_\text{SH}$, thus $$P_\text{TOT} =  P_\text{NBI} + P_\text{ICR} + P_\text{OH} - P_\text{SH}$$
```{python}
#| echo: true
#| code-fold: true
#| code-summary: "Code for finding P_TOT/P_LH"
from typing import Dict, List
from scipy.interpolate import interp1d 
def p_lh_threshold_martin_scaling_from_pulse_dict(pulse_dict: Dict[str, Dict[str, np.ndarray]]) -> List[np.ndarray]: 
    """ Using martin scaling we find the ratio of the PTOT/PLH 
    This is done by first interpolating all diagnostics used onto a common time domain 
    The common time domain is given by the lowest order sampled parameter used in the martin scaling 

    The power variables are then interpolated to the same axis 
    """
    power_scaling = lambda n, r, a, b : (2.14)*(np.exp(0.107))*(np.power(n*1e-20,0.728))*(np.power(abs(b),0.772))*(np.power(a,0.975))*(np.power(r,0.999))
    lh_threshold_diagnostic_signal_names = ['kg1l/lad3', 'efit/Rgeo', 'efit/ahor', 'magn/BTF']
    # Finds the lowest sampled signal so we can interpolate onto that domain
    data_size_list = [(diag_sig, signal_dims['data'].shape) for diag_sig, signal_dims in pulse_dict.items() if diag_sig in lh_threshold_diagnostic_signal_names]
    domain_diagnostic, _ = min(data_size_list, key=lambda t: t[1]) # https://docs.python.org/3.8/library/functions.html#min
    diagnostics_to_interpolate = [d for d in lh_threshold_diagnostic_signal_names if d != domain_diagnostic]
    time_domain = pulse_dict[domain_diagnostic]['time'].copy()

    interpolated_dict = {domain_diagnostic: pulse_dict[domain_diagnostic]['data']}

    for key in diagnostics_to_interpolate: 
        _interp = interp1d(pulse_dict[key]['time'], pulse_dict[key]['data'])
        interp_data = _interp(time_domain)
        interpolated_dict[key] = interp_data

    plh_threshold = 1e6*power_scaling(*[interpolated_dict[key] for key in lh_threshold_diagnostic_signal_names])
    # Now to compare against the input power 
    power_diagnostic_signal_names = ['power/PNBI_TOT', 'power/P_OH', 'power/PICR_TOT', 'nbip/shi']
    total_power = np.zeros_like(time_domain)
    for key in power_diagnostic_signal_names: 
        try: 
            _interp = interp1d(pulse_dict[key]['time'], pulse_dict[key]['data'], bounds_error=False, fill_value=0.0)
            power_interped = _interp(time_domain)
        except ValueError: 
            power_interped = np.zeros_like(time_domain)
        except KeyError as e: 
            if e.args[0] == 'nbip/shi':
                power_interped = np.zeros_like(time_domain)
            else: 
                raise KeyError('pulse_dict does not contain the following necessary dignostics diagnostics: {}'.format(power_diagnostic_signal_names + lh_threshold_diagnostic_signal_names))
        if key in ['nbip/sh']: 
            total_power -= power_interped
        else:     
            total_power += power_interped
    ratio_threshold_total_power = total_power / plh_threshold
    # above_lh_threshold = time_domain[total_power > plh_threshold]
    # t_start, t_end = above_lh_threshold[0], above_lh_threshold[-1]
    return [time_domain, plh_threshold, ratio_threshold_total_power]

```

```{python}
#| eval: false


# diagnostic_names = ['bolo/topi', 'ehtr/wdia', 'kg1l/lad3', 'nbip/shi', 'efit/Rgeo', 'efit/ahor', 'magn/BTF', ]
# lh_threshold_diagnostic_signal_names = ['kg1l/lad3', 'efit/Rgeo', 'efit/ahor', 'magn/BTF', '']
diagnostic_signal_names = ['kg1l/lad3', 'efit/Rgeo', 'efit/ahor', 'magn/BTF', 'power/PNBI_TOT', 'power/P_OH', 'power/PICR_TOT', 'nbip/shi']
shot_number = 81768

example_dict = get_dict_params(shot_number, diagnostic_signal_names, conn)

time_domain, plh_threshold,ratio_threshold_total_power = p_lh_threshold_martin_scaling_from_pulse_dict(example_dict)
fig = plt.figure()
plt.title(f'JET #{shot_number}')
plt.plot(time_domain, ratio_threshold_total_power)
plt.xlabel('Time (s)')
plt.ylabel('$P_{TOT} / P_{LH}$')
plt.axhline(1.0, ls='--', color='black')
plt.show()


```

```{python}
#| label: lhratio-pulses
#| fig-cap: "This approach picks up the L-H transition, but not the back transition. If we were to use this to define the start and end of H-mode, it is prone to the following artifacts: i) When a PINI drops, the $P_{TOT} >= P_{LH}$ can drop below 1, even though we are still in H-mode, ii) near rampdown, any number of the parameters could spike, (see JET #86540 and 83304), iii) at the very beginning, there is a spike in density"

martin_scaling_signal_names = ['kg1l/lad3', 'efit/Rgeo', 'efit/ahor', 'magn/BTF']
power_signal_names = ['power/PNBI_TOT', 'power/P_OH', 'power/PICR_TOT', 'nbip/shi']
diagnostic_signal_names =  [*martin_scaling_signal_names, *power_signal_names]

# sample_shot_nums = random.sample(shot_list, k=5)
sample_shot_nums = [] 

for idx in random.sample(range(len(shot_list)), len(shot_list)): 
    if len(sample_shot_nums) == 9: 
        break 
    sample_shot = shot_list[idx]
    if get_dict_params(sample_shot, diagnostic_signal_names, conn) is not None: 
        sample_shot_nums.append(sample_shot)

fig1, f1_axes = plt.subplots(ncols=3, nrows=3, constrained_layout=True, figsize=(10, 10), sharex=True)
f1_axes = f1_axes.ravel()
for i, shot_number in enumerate(sample_shot_nums): 
    example_dict = get_dict_params(shot_number, diagnostic_signal_names, conn)
    if example_dict is None: 
        print(shot_number)
        continue 
    time_domain, plh_threshold,ratio_threshold_total_power = p_lh_threshold_martin_scaling_from_pulse_dict(example_dict)
    # f1_axes[i].subplot(len(sample_shot_nums), 1, k+1)
    f1_axes[i].set_title(f'JET #{shot_number}')
    f1_axes[i].plot(time_domain, ratio_threshold_total_power)
    _window = np.logical_and(ratio_threshold_total_power > 1.0, np.logical_and(time_domain > 44, time_domain < 60))
    f1_axes[i].plot(time_domain[_window], ratio_threshold_total_power[_window], color='red')
    f1_axes[i].scatter(time_domain[_window], ratio_threshold_total_power[_window], color='red', s=5)
    f1_axes[i].axvline(time_domain[_window][0], color='black', ls='--')
    f1_axes[i].axvline(time_domain[_window][-1], color='black', ls='--')
    f1_axes[i].set_xlabel('Time (s)')
    f1_axes[i].set_ylabel('$P_{TOT} / P_{LH}$ [-]')
    f1_axes[i].axhline(1.0, ls='--', color='black')
    f1_axes[i].set_xlim(40, 60)

    # f1_axes[i].yaxis.set_tick_params(which='both')

for ax in fig1.get_axes():
    ax.label_outer()
for ax in fig1.get_axes(): 
    ax.yaxis.set_tick_params(which='both', labelbottom=True)
    # plt.setp(ax.get_yticklabels(), visible=True)

fig1.suptitle('Ratio of martin scaling with total power')
plt.show()

```
#### But how to get the time windows for H-mode? 

## 2. Finding steady states
Here we want to find periods of near-constant global plasma parameters, namely the stored diamagnetic energy, $W_\text{DIA}$ [J]. The bounds for which a window or period of steady state can occur are made via: 

1. $\frac{P_{TOT}}{P_{LH}} >= 1$ 
2. times of the window $t$ exist between $44 < t < 60$ (for JET)
    - This is temporary, but should exclude times during rampdown and rampup where the LH-HL threshold can occur (although this should be investigated?)
    - Ideally, we pass a sliding window over the proposed $P_{ratio} > 1$ that removes outliers.  


```{python}
#| eval: false 
from typing import Dict, Union
def plot_time_traces(pulse_dict: Dict[str, Dict[str, np.ndarray]], shot_number: Union[int, str]) -> None: 
    machine_param_signals = ['efit/Rgeo','efit/k', 'efit/ahor', 'efit/delRoben', 'efit/delRuntn', 'efit/Vol', 'gas/D_tot', 'magn/IpiFP', 'magn/q95',  'magn/BTF', 'power/PNBI_TOT', 'power/P_OH', 'power/PICR_TOT']
    global_param_signals = ['bolo/topi', 'ehtr/wdia', 'kg1l/lad3', ]
    power_signal_names = ['power/PNBI_TOT', 'power/P_OH', 'power/PICR_TOT', 'nbip/shi']
    magnetic_signal_names = ['magn/IpiFP', 'magn/q95', 'magn/BTF']
    elm_param_signals = ['edg8/tbeo', 'edg8/tbei']
    group_dict = {'MA, -, T': [('magn/IpiFP', 1e-6), ('magn/q95', 1.0), ('magn/BTF', 1.0)],
                 'MW': [(sig, 1e-6) for sig in power_signal_names], 
                 '$10^{22}$ e/s': [('gas/D_tot', 1e-22)], 
                 '$10^{20}$ m$^{-3}$': [('kg1l/lad3', 1e-20)], 
                 'MJ, MW': [('bolo/topi', 1e-6), ('ehtr/wdia', 1e-6)], 
                 'ph/s/cm$^{2}$/sr': [('edg8/tbeo', 1e-13), ('edg8/tbei', 1e-13)]}

    fig, fig_axs = plt.subplots(3, 2, figsize=(10, 10), sharex=True)
    fig_axs = fig_axs.ravel()
    for i, (units, signal_scalar_tuple) in enumerate(group_dict.items()):
        for signal_name, scalar in signal_scalar_tuple: 
            fig_axs[i].plot(pulse_dict[signal_name]['time'], abs(scalar*pulse_dict[signal_name]['data']), label=signal_name.split('/')[-1])
        fig_axs[i].set_ylabel(units)
        if units == 'MA, -, T': 
            fig_axs[i].set_ylim(0, 6)

    for ax in fig.get_axes():
        ax.set_xlim(40, 60)
        ax.legend(frameon=False)
        ax.grid()
    fig.subplots_adjust(hspace=0.0, wspace=0.4)
    fig.suptitle(f'JET #{shot_number}')
    plt.show()

machine_param_signals = ['efit/Rgeo','efit/k', 'efit/ahor', 'efit/delRoben', 'efit/delRuntn', 'efit/Vol', 'gas/D_tot', 'magn/IpiFP', 'magn/q95',  'magn/BTF', 'power/PNBI_TOT', 'power/P_OH', 'power/PICR_TOT']
global_param_signals = ['bolo/topi', 'ehtr/wdia']
elm_param_signals = ['edg8/tbeo', 'edg8/tbei']
diagnostic_signal_names = list(set(diagnostic_signal_names + machine_param_signals + global_param_signals + elm_param_signals))
shot_number = sample_shot_nums[0]
example_dict = get_dict_params(shot_number, diagnostic_signal_names, conn)
# print(example_dict.keys())

plot_time_traces(example_dict, shot_number)
```

#### Algorithm to determine where things are in the steady state 

1. Using [**rupture**](https://centre-borelli.github.io/ruptures-docs/)@Truong2020, find the change points in $W_\text{dia}$
    - The change points are separated by a minimum of 0.5 seconds 
2. Filter the change points selected to be those that fall between bounds set above 
3. The times bewteen change points, i.e., windows, are a steady state if the slope of $W_\text{DIA}$ between the change points is less than $15%$ the mean of the window. 
```{python}
#| echo: true
#| code-fold: true
#| code-summary: "Code for finding steady states"

import ruptures as rpt 
from typing import Dict, List, Tuple
def find_steady_state_windows(pulse_dict: Dict[str, Dict[str, np.ndarray]]) -> Tuple[List[Tuple[float, float]], Tuple[float, float], Tuple[np.ndarray, np.ndarray]]: 
    """ Uses ruptures to find steady state windows using the PLH threshold and the diamagnetic energy """
    if not 'ehtr/wdia' in pulse_dict.keys(): raise KeyError('must include ehtr/wdia in list of diagnostics to pull')
    lh_domain, _, ratio_threshold_total_power = p_lh_threshold_martin_scaling_from_pulse_dict(pulse_dict)
    h_mode_window = np.logical_and(ratio_threshold_total_power > 1.0, np.logical_and(lh_domain > 44, lh_domain < 60))
    t_start_hmode, t_end_hmode = lh_domain[h_mode_window][0], lh_domain[h_mode_window][-1]

    time, data = example_dict['ehtr/wdia']['time'], example_dict['ehtr/wdia']['data']
    # window_size should be like 1248
    dt = (time[-1] - time[0])/len(time)
    time_window_size = 0.5 # 0.5 seconds 
    window_size = int(0.5 / dt)
    
    algo = rpt.Pelt(model='l2', min_size=window_size).fit(data)
    n, dim, sigma = len(time), 1, 1
    pen = np.log(n) * dim * sigma**2
    my_bkps = algo.predict(pen=pen)
    t_bkps = np.array([time[bkp] for bkp in my_bkps if bkp != len(time)])
    t_bkps_in_hmode = t_bkps[np.logical_and(t_bkps > t_start_hmode, t_bkps <= t_end_hmode)]

    t_window_steady_states = []
    for t_idx, t in enumerate(t_bkps_in_hmode): 
        if t_idx == 0: 
            t_beg, t_end = t_start_hmode, t
        elif t_idx == len(t_bkps_in_hmode): 
            t_beg, t_end = t, t_end_hmode
        else: 
            t_beg, t_end = t_bkps_in_hmode[t_idx-1], t
        _window_bool = np.logical_and(time >= t_beg, time <= t_end)
        slope = (data[_window_bool][-1] - data[_window_bool][0]) / (time[_window_bool][-1] - time[_window_bool][0])
        if abs(slope / data[_window_bool].mean()) < 0.15: 
            t_window_steady_states.append((t_beg, t_end))
    return t_window_steady_states, (t_start_hmode, t_end_hmode), (lh_domain, ratio_threshold_total_power)

```

```{python}
machine_param_signals = ['efit/Rgeo','efit/k', 'efit/ahor', 'efit/delRoben', 'efit/delRuntn', 'efit/Vol', 'gas/D_tot', 'magn/IpiFP', 'magn/q95',  'magn/BTF', 'power/PNBI_TOT', 'power/P_OH', 'power/PICR_TOT']
global_param_signals = ['bolo/topi', 'ehtr/wdia', 'kg1l/lad3'] 
elm_param_signals = ['edg8/tbeo', 'edg8/tbei']
diagnostic_signal_names = list(set(machine_param_signals + global_param_signals + elm_param_signals))

# fig, axs = plt.subplots(ncols=2, nrows=4, constrained_layout=True, figsize=(10, 10))


fig = plt.figure(figsize=(15, 15))
gs_init = gridspec.GridSpec(3, 3, figure=fig)

for k, shot_number in enumerate(sample_shot_nums[:9]): 
    example_dict = get_dict_params(shot_number, diagnostic_signal_names, conn)
    t_window_steady_states, ( t_start_hmode, t_end_hmode), (lh_domain, ratio_threshold_total_power) = find_steady_state_windows(example_dict)

    # col = 0 if k<= 1 else 1 
    if k<= 1: 
        col = 0 
    elif k <= 3: 
        col = 1 
    else: 
        col = 2
    row = k % 3

    gs_pulse = gridspec.GridSpecFromSubplotSpec(2, 1, subplot_spec=gs_init[k], hspace=0.0)
    ax1 = fig.add_subplot(gs_pulse[0])
    ax1.set_title(f'JET #{shot_number}')
    ax1.plot(lh_domain, ratio_threshold_total_power, label='$P_{TOT} / P_{LH}$')
    ax1.axhline(1.0, ls='--', color='grey')
    ax1.set_ylabel('-')

    ax2 = fig.add_subplot(gs_pulse[1])
    time, data = example_dict['ehtr/wdia']['time'], 1e-6*example_dict['ehtr/wdia']['data']
    ax2.plot(time, data, label='wdia')
    ax2.set_ylabel('MJ')

    for (t_beg, t_end) in t_window_steady_states: 
        _window_bool = np.logical_and(time >= t_beg, time <= t_end)
        ax2.plot(time[_window_bool], data[_window_bool], color='violet')
        ax2.axvline(t_beg, color='green', ls='--')
        ax2.axvline(t_end, color='green', ls='--')

    for ax in [ax1, ax2]: 
        ax.axvline(t_start_hmode, ls='--', color='black')
        ax.axvline(t_end_hmode, ls='--', color='black')
        ax.set_xlim(t_start_hmode - 1, t_end_hmode + 1)
    
for ax in fig.get_axes():
    # ax.set_xlim(40, 60)
    ax.legend(frameon=False)
    ax.grid()
    ax.label_outer()

plt.show()
```

How do these windows with other parameters? We are often interested in what happens when the power changes, or gas puff, etc., 


- Machine parameters (heirarchial structure?)
    - **Shaping**: $R$, $a$, $\delta_u$, $\delta_o$, $V_P$,  **Gas**: $\Gamma_D$, **Power**: Defined above, **Magnetic**: $q_{95}$, $I_P$, $B_T$
- Global Parameters
    - Radiated power from bolometer,  Diamagnetic Stored energy of the plasma, Line averaged density, Average inner/outer Be II photon flux (ELMs)

## 3. ELM Timings 

The algorithm implemented in @ELM_TIMINGS_PREPRINT is simplified as follows: 

- 'up-sample' the signals
    - DCT of signal, append 0s up to the highest sampling frequency range for each signal used
    - Inverse DCT back to real space 
- take first derivative 'up-sampled' signal.
- From each differentiated signal, the $1-\nu$ largest points are labeled as canidates, where $\nu$ is a percentile filter for thresholding (optimal 0.997)
    - `scipy.signal.find_peaks`

```{python}
"""
fig = plt.figure(figsize=(15, 15))
gs_init = gridspec.GridSpec(2, 2, figure=fig)

for k, shot_number in enumerate(sample_shot_nums[:4]): 
    example_dict = get_dict_params(shot_number, diagnostic_signal_names, conn)

    col = 0 if k<= 1 else 1 
    row = k % 2
    gs_pulse = gridspec.GridSpecFromSubplotSpec(2, 1, subplot_spec=gs_init[k], hspace=0.0)
    
    for idx, param in enumerate(elm_param_signals): 
        ax = fig.add_subplot(gs_pulse[idx])
        if idx == 0: 
            ax.set_title(f'JET #{shot_number}')
        ax.plot(example_dict[param]['time'], example_dict[param]['data'], label=param.split('/')[-1])
"""
machine_param_signals = ['efit/Rgeo','efit/k', 'efit/ahor', 'efit/delRoben', 'efit/delRuntn', 'efit/Vol', 'gas/D_tot', 'magn/IpiFP', 'magn/q95',  'magn/BTF', 'power/PNBI_TOT', 'power/P_OH', 'power/PICR_TOT']
global_param_signals = ['bolo/topi', 'ehtr/wdia', 'kg1l/lad3'] 
elm_param_signals = ['edg8/tbeo', 'edg8/tbei']
diagnostic_signal_names = list(set(machine_param_signals + global_param_signals + elm_param_signals))

shot_number = sample_shot_nums[1]
example_dict = get_dict_params(shot_number, diagnostic_signal_names, conn)

t_window_steady_states, (t_start_hmode, t_end_hmode), (lh_domain, ratio_threshold_total_power) = find_steady_state_windows(example_dict)
from scipy.fft import dct, idct

fig, axs = plt.subplots(2, 1, figsize=(10, 10), sharex='col')

for idx, param in enumerate(elm_param_signals): 
    ax = axs[idx]
    if idx == 0: 
        ax.set_title(f'JET #{shot_number}')

    time, data = example_dict[param]['time'], example_dict[param]['data']
    ax.plot(time, data, label=param.split('/')[-1])

    ax.set_xlim(t_start_hmode -1, t_end_hmode+1)

    for (t_beg, t_end) in t_window_steady_states: 
        _window_bool = np.logical_and(time >= t_beg, time <= t_end)
        ax.plot(time[_window_bool], data[_window_bool], color='violet')
        ax.axvline(t_beg, color='green', ls='--')
        ax.axvline(t_end, color='green', ls='--')

    ax.legend()

    inset_1 = ax.inset_axes([0.1, 0.5, 0.3, 0.3])
    (t_beg, t_end) = t_window_steady_states[0]
    _window_bool = np.logical_and(time >= t_beg, time <= t_end)
    _time, _data = time[_window_bool], data[_window_bool]
    inset_1.plot(_time, _data)
    # inset_1.plot(_time, np.diff(_data, prepend=0.0))
    upsampled = np.zeros(10000)
    upsampled[:len(_data)] = dct(_data-data.mean() / data.std())
    print(idct(upsampled).shape)
    upsampled_idct = idct(upsampled, n=len(_time))
    inset_1.plot(_time, upsampled_idct)
    ax.indicate_inset_zoom(inset_1, edgecolor="black")

    inset = ax.inset_axes([0.6, 0.2, 0.3, 0.3])
    (t_beg, t_end) = t_window_steady_states[-1]
    _window_bool = np.logical_and(time >= t_beg, time <= t_end)
    _time, _data = time[_window_bool], data[_window_bool]
    inset.plot(_time, _data)
    ax.indicate_inset_zoom(inset, edgecolor="black")
   

plt.show()
```

## 4. Bayesian fitting 

this isn't really automating things but rather a better way to fit. 
